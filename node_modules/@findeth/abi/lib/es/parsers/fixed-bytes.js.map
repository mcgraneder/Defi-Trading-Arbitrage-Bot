{"version":3,"sources":["../../../src/parsers/fixed-bytes.ts"],"names":["addPadding","concat","toBuffer","BYTES_REGEX","isFixedBytes","type","test","getByteLength","bytes","match","length","Number","Error","encodeFixedBytes","buffer","value","bufferValue","decodeFixedBytes","_","subarray"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,MAArB,EAA6BC,QAA7B,QAA6C,iBAA7C;AAGA,MAAMC,WAAW,GAAG,qBAApB;AAEA,OAAO,MAAMC,YAAY,GAAIC,IAAD,IAA2B;AACrD,SAAOF,WAAW,CAACG,IAAZ,CAAiBD,IAAjB,CAAP;AACD,CAFM;AAWP,OAAO,MAAME,aAAa,GAAIF,IAAD,IAA0B;AAAA;;AACrD,QAAMG,KAAK,kBAAGH,IAAI,CAACI,KAAL,CAAWN,WAAX,CAAH,gDAAG,YAA0B,CAA1B,CAAd;;AAEA,MAAIK,KAAJ,EAAW;AACT,UAAME,MAAM,GAAGC,MAAM,CAACH,KAAD,CAArB;;AACA,QAAIE,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAG,EAA5B,EAAgC;AAC9B,YAAM,IAAIE,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,WAAOF,MAAP;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD,CAbM;AAeP,OAAO,MAAMC,gBAAgC,GAAG,CAC9CC,MAD8C,EAE9CC,KAF8C,EAG9CV,IAH8C,KAI/B;AACf,QAAMK,MAAM,GAAGH,aAAa,CAACF,IAAD,CAA5B;AACA,QAAMW,WAAW,GAAGd,QAAQ,CAACa,KAAD,CAA5B;;AAEA,MAAIC,WAAW,CAACN,MAAZ,GAAqBA,MAAzB,EAAiC;AAC/B,UAAM,IAAIE,KAAJ,CAAW,gCAA+BF,MAAO,SAAQM,WAAW,CAACN,MAAO,EAA5E,CAAN;AACD;;AAED,SAAOT,MAAM,CAACa,MAAD,EAASd,UAAU,CAACgB,WAAD,CAAnB,CAAb;AACD,CAbM;AAeP,OAAO,MAAMC,gBAAgC,GAAG,CAACF,KAAD,EAAoBG,CAApB,EAAmCb,IAAnC,KAAgE;AAC9G,QAAMK,MAAM,GAAGH,aAAa,CAACF,IAAD,CAA5B;AAEA,SAAOU,KAAK,CAACI,QAAN,CAAe,CAAf,EAAkBT,MAAlB,CAAP;AACD,CAJM","sourcesContent":["import { addPadding, concat, toBuffer } from '../utils/buffer';\nimport { DecodeFunction, EncodeFunction } from './parser';\n\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/;\n\nexport const isFixedBytes = (type: string): boolean => {\n  return BYTES_REGEX.test(type);\n};\n\n/**\n * Get the length of the specified type. If a length is not specified, or if the length is out of range (0 < n <= 32),\n * this will throw an error.\n *\n * @param {string} type\n * @return {number | undefined}\n */\nexport const getByteLength = (type: string): number => {\n  const bytes = type.match(BYTES_REGEX)?.[1];\n\n  if (bytes) {\n    const length = Number(bytes);\n    if (length <= 0 || length > 32) {\n      throw new Error('Invalid type: length is out of range');\n    }\n\n    return length;\n  }\n\n  throw new Error('Invalid type: no length');\n};\n\nexport const encodeFixedBytes: EncodeFunction = (\n  buffer: Uint8Array,\n  value: string | Uint8Array,\n  type: string\n): Uint8Array => {\n  const length = getByteLength(type);\n  const bufferValue = toBuffer(value);\n\n  if (bufferValue.length > length) {\n    throw new Error(`Buffer is too long, expected ${length}, got ${bufferValue.length}`);\n  }\n\n  return concat(buffer, addPadding(bufferValue));\n};\n\nexport const decodeFixedBytes: DecodeFunction = (value: Uint8Array, _: Uint8Array, type: string): Uint8Array => {\n  const length = getByteLength(type);\n\n  return value.subarray(0, length);\n};\n"],"file":"fixed-bytes.js"}